---
title: "linear_models"
output: html_document
---

```{r}
library(tidyverse)
library(p8105.datasets)
```

Load NYC airbnb data
```{r}
data(nyc_airbnb)
```

Look at the data
```{r}
nyc_airbnb =
  nyc_airbnb |>
  mutate(
    stars = review_scores_location / 2
  ) |>
  rename(
    borough = neighbourhood_group
  ) |>
  filter(borough !="Staten Island") |>
  select(price, stars, borough, room_type, neighbourhood)
```

Do regression!
```{r}
fit = lm(price ~ stars + borough, data = nyc_airbnb)
```

Do some additional cleaning then refit. fct_freq function looks through your data and makes the reference group the most popular one. In this case it's Manhattan. Without telling it what to do, it goes by alphabetical order (first one in the alphabet will be the reference by default)
```{r}
nyc_airbnb =
  nyc_airbnb |>
  mutate(
    borough = fct_infreq(borough),
    room_type = fct_infreq(room_type)
  )

fit = lm(price ~ stars + borough, data = nyc_airbnb)
```

Look at 'lm' stuff, but not very tidy.
```{r, eval = FALSE}
summary(fit)
names(summary(fit))
summary(fit)[["coefficients"]]
summary(fit)[["df"]]

fitted.values(fit)
```

Look at cleaner 'lm' stuff using broom function.
```{r}
fit |>
  broom::tidy() |>
  mutate(
    term = str_replace(term, "borough", "Borough: ")
  ) |>
  select(term, estimate, p.value) |>
  knitr::kable(digits = 3)

fit |>
  broom::glance()
```

Look at residuals. Modelr is a package that computes things for you like residuals.
```{r}
nyc_airbnb |>
  modelr::add_residuals(fit) |>
  modelr::add_predictions(fit) |>
  filter(resid < 1000) |> ## Did this because the outlier made the scale of the graph too big for good visualization of the distribution
  ggplot(aes(x = resid)) +
  geom_histogram()

nyc_airbnb |>
  modelr::add_residuals(fit) |>
  modelr::add_predictions(fit) |>
  filter(resid < 1000) |>
  ggplot(aes(x = borough, y = resid)) +
  geom_violin()

nyc_airbnb |>
  modelr::add_residuals(fit) |>
  modelr::add_predictions(fit) |>
  filter(resid < 1000) |>
  ggplot(aes(x = stars, y = resid)) +
  geom_point()
```

Hypothesis testing
```{r}
fit |>
  broom::tidy()
```

What about a categorical variable?
```{r}
fit_alt = lm(price ~ stars + borough + room_type, data = nyc_airbnb)
fit_null = lm(price ~ stars + borough, data = nyc_airbnb)

anova(fit_null, fit_alt) |>
  broom::tidy()
```

## Interactions vs nested data. When you run this, the interaction terms are the estimates with the colons between the covariates.
```{r}
fit_interactions =
  lm(price ~ stars * borough + room_type * borough, data = nyc_airbnb)

fit_interactions |>
  broom::tidy()
```

Let's just look at Brooklyn first. The underscore at data means use the data frame from before in the lm function.
```{r}
nyc_airbnb |>
  filter(borough == "Brooklyn") |>
  lm(price ~ stars + room_type, data = _) |>
  broom::tidy()

nyc_airbnb |>
  filter(borough == "Manhattan") |>
  lm(price ~ stars + room_type, data = _) |>
  broom::tidy()

nyc_airbnb |>
  filter(borough == "Bronx") |>
  lm(price ~ stars + room_type, data = _) |>
  broom::tidy()

nyc_airbnb |>
  filter(borough == "Queens") |>
  lm(price ~ stars + room_type, data = _) |>
  broom::tidy()
```

Write a short function
```{r}
lm_airbnb = function(df){
  
  lm(price ~ stars + room_type, data= df)
  
}

nyc_airbnb |>
  filter(borough == "Queens") |>
  lm_airbnb() |>
  broom::tidy()
```

Create a list of dataframes, and iterate to fit th emodel each time.
```{r}
nested_lm_results =
  nyc_airbnb |>
  nest(data = -borough) |> #Does everything except for borough
  mutate(
    fits = map(data, lm_airbnb),
    results = map(fits, broom::tidy)
  ) |>
  select(borough, results) |>
  unnest(results) # Releases individual model results
```

```{r}
nested_lm_results |>
  select(borough, term, estimate) |>
  pivot_wider(
    names_from = term,
    values_from = estimate
  )
```

Use an *anonymous* function instead of 'lm_airbnb'
```{r}
nested_lm_results =
  nyc_airbnb |>
  nest(data = -borough) |> 
  mutate(
    fits = map(data, \(df) lm(price ~ stars + room_type, data = df)),
    results = map(fits, broom::tidy)
  ) |>
  select(borough, results) |>
  unnest(results) 
```

A more extreme example
```{r}
manhattan_analysis =
  nyc_airbnb |>
  filter(
    borough == "Manhattan"
  ) |>
  nest(data = -neighbourhood) |>
  mutate(
    fits = map(data, \(df) lm(price ~ stars + room_type, data = df)),
    results = map(fits, broom:: tidy)
  ) |>
  select(neighbourhood, results) |>
  unnest(results)
```

Make a plot
```{r}
manhattan_analysis |>
  filter(term == "stars") |>
  mutate(
    neighbourhood = fct_reorder(neighbourhood, estimate)
  ) |>
  ggplot(aes(x = neighbourhood, y = estimate)) +
  geom_point() +
  theme(axis.text.x = element_text(angle = 45, hjust =1))
```

